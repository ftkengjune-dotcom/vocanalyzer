<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>준쌤의 암기 요정</title>
  <style>
    .seg-prefix { color:#d00; font-weight:700; } /* 빨강 */
    .seg-root   { color:inherit; }               /* 검정(기본) */
    .seg-suffix { color:#06c; font-weight:700; } /* 파랑 */
    body { font-family: ui-sans-serif, system-ui, -apple-system; max-width: 720px; margin: 40px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin-bottom: 12px; }
    .row { display: flex; gap: 8px; }
    input[type="text"] { flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 10px 16px; border: 1px solid #333; background:#111; color:#fff; border-radius:10px; cursor:pointer; }
    button:disabled { opacity: .6; cursor: wait; }
    #ResultArea { margin-top: 18px; white-space: pre-wrap; line-height: 1.6; border: 1px solid #eee; border-radius: 10px; padding: 12px; }
  </style>
</head>
<body>
  <h1>준쌤의 암기 요정</h1>
  <div class="row">
    <input id="wordinput" type="text" placeholder="영어 단어 입력 (예: reconstruction)" />
    <button id="analbtn">분석하기</button>
  </div>
  <pre id="ResultArea"></pre>

  <script>
  function escapeHtml(s) {
  return String(s ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
  }[m]));
}

/* 한국어 설명식("접두어 re-는 ...")에서도 원형을 추출하려는 가벼운 규칙 */
function extractMorphemes(segments) {
  let prefix=null, root=null, suffix=null;

  // 영어 스키마가 온다면 그대로
  if (segments && typeof segments === "object") {
    if (typeof segments.prefix === "string") prefix = segments.prefix.replace(/-$/,"").trim() || null;
    if (typeof segments.root   === "string") root   = segments.root.replace(/^-|-$/g,"").trim()   || null;
    if (typeof segments.suffix === "string") suffix = segments.suffix.replace(/^-/, "").trim()     || null;
  }

  // 한국어 스키마(설명 문장)에서 추출 시도
  if (!prefix && typeof segments?.["접두어"] === "string") {
    const m = segments["접두어"].match(/([A-Za-z]+)-|([A-Za-z]+)\b/);
    prefix = (m && (m[1] || m[2])) || null;
  }
  if (!root && typeof segments?.["어근"] === "string") {
    const m = segments["어근"].match(/\b([A-Za-z]+)\b/);
    root = (m && m[1]) || null;
  }
  if (!suffix && typeof segments?.["접미사"] === "string") {
    const m = segments["접미사"].match(/-([A-Za-z]+)|\b([A-Za-z]+)\b/);
    suffix = (m && (m[1] || m[2])) || null;
  }

  return { prefix, root, suffix };
}

/* 단어를 접두/어근/접미사로 색칠 (가능한 부분만) */
function colorizeWord(word, segs) {
  const w = String(word || "");
  const lw = w.toLowerCase();
  const p = segs.prefix ? segs.prefix.toLowerCase() : null;
  const r = segs.root   ? segs.root.toLowerCase()   : null;
  const s = segs.suffix ? segs.suffix.toLowerCase() : null;

  let html = "";
  let pos = 0;

  // 1) 접두어가 "정확히 앞"에 있으면 빨강
  if (p && lw.startsWith(p)) {
    const pre = w.slice(0, p.length);
    html += `<span class="seg-prefix">${escapeHtml(pre)}</span>`;
    pos = p.length;
  }

  // 2) 접미사가 "정확히 뒤"에 있으면 위치 기억
  let suffixStart = null;
  if (s && lw.endsWith(s)) {
    suffixStart = w.length - s.length;
  }

  // 3) 어근이 있으면 그 위치를 찾아 검정으로 표시
  if (r) {
    const idx = lw.indexOf(r, pos);
    if (idx !== -1 && (suffixStart === null || idx + r.length <= suffixStart)) {
      // 접두어 이후~접미어 이전 사이의 일반 부분(있다면) 추가
      if (idx > pos) html += escapeHtml(w.slice(pos, idx));
      // 어근(검정)
      html += `<span class="seg-root">${escapeHtml(w.slice(idx, idx + r.length))}</span>`;
      pos = idx + r.length;
    }
  }

  // 4) 접미사 처리
  if (suffixStart !== null) {
    // 어근 이후~접미사 이전 일반 부분
    if (pos < suffixStart) html += escapeHtml(w.slice(pos, suffixStart));
    // 접미사(파랑)
    html += `<span class="seg-suffix">${escapeHtml(w.slice(suffixStart))}</span>`;
    pos = w.length;
  }

  // 5) 남은 부분(아무 규칙에도 안 걸린 중간/끝)은 기본 검정
  if (pos < w.length) html += escapeHtml(w.slice(pos));

  // 어느 것도 매칭 안 되면(=html이 비어있으면) 원문 반환
  return html || escapeHtml(w);
}
    
  const $input = document.getElementById("wordinput");
  const $btn = document.getElementById("analbtn");
  const $out = document.getElementById("ResultArea");

  function setBusy(b) {
    $btn.disabled = b;
    $btn.textContent = b ? "분석 중..." : "분석하기";
  }

  function renderResult(j) {
    // 영어/한국어 스키마 모두 지원
    const word      = j.word ?? j["단어"] ?? "";
    const segments  = j.segments ?? j["분석 결과"] ?? {};
    const meaning   = j.meaning ?? j["단어 뜻"] ?? {};
    const etymology = j.etymology ?? j["어원"] ?? "";
    const mnemonic  = j.mnemonic_image ?? j["쉽게 외우려면?"] ?? "";

    const lines = [];
    if (word) lines.push(`● 단어: ${word}`);

    // 1) 형태소/분석 결과
    // 영어 스키마: { prefix, root, suffix, other_morphemes[] }
    if (segments && (segments.prefix || segments.root || segments.suffix || Array.isArray(segments.other_morphemes))) {
      if (segments.prefix)  lines.push(`● 접두어: ${segments.prefix}`);
      if (segments.root)    lines.push(`● 어근: ${segments.root}`);
      if (segments.suffix)  lines.push(`● 접미사: ${segments.suffix}`);
      if (Array.isArray(segments.other_morphemes) && segments.other_morphemes.length) {
        lines.push(`● 기타 구성: ${segments.other_morphemes.join(", ")}`);
      }
    }
    // 한국어 스키마(설명 문장): { "접두어": "...", "어근": "...", "접미사": "..." }
    if (segments && (segments["접두어"] || segments["어근"] || segments["접미사"])) {
      if (segments["접두어"]) lines.push(`● 접두어: ${segments["접두어"]}`);
      if (segments["어근"])   lines.push(`● 어근: ${segments["어근"]}`);
      if (segments["접미사"]) lines.push(`● 접미사: ${segments["접미사"]}`);
    }

    // 2) 뜻
    const kr = meaning.kr ?? meaning["한국어"];
    const en = meaning.en ?? meaning["영영"];
    if (kr) lines.push(`● 뜻(한): ${kr}`);
    if (en) lines.push(`● 뜻(영): ${en}`);

    // 3) 어원
    if (etymology) lines.push(`● 어원: ${etymology}`);

    // 4) 연상 이미지
    if (mnemonic) lines.push(`● 연상 이미지: ${mnemonic}`);

    // 에러 응답 처리(백엔드에서 error/detail 보낼 때)
    if (j.error) {
      lines.length = 0;
      lines.push("오류가 발생했습니다.");
      lines.push(`- error: ${j.error}`);
      if (j.detail) lines.push(`- detail: ${typeof j.detail === "string" ? j.detail : JSON.stringify(j.detail)}`);
    }

    // 아무 것도 못 뽑았으면 원문 노출(디버깅용)
    if (lines.length === 0) {
      $out.textContent = typeof j === "string" ? j : JSON.stringify(j, null, 2);
      return;
    }

    $out.textContent = lines.join("\n");
  }

  async function analyze() {
    const word = ($input.value || "").trim();
    if (!word) return alert("단어를 입력하세요!");
    setBusy(true);
    $out.textContent = "분석 중...";

    try {
      const res = await fetch("/analyze", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ word })
      });

      const text = await res.text();
      let data;
      try { data = JSON.parse(text); }
      catch { data = { raw: text }; }

      renderResult(data);
    } catch (e) {
      $out.textContent = "요청 실패: " + (e?.message || e);
    } finally {
      setBusy(false);
    }
  }

  $btn.addEventListener("click", analyze);
  $input.addEventListener("keydown", (e) => { if (e.key === "Enter") analyze(); });
  </script>
</body>
</html>

