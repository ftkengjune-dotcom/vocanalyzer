<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ“–ğŸ“–ì¤€ìŒ¤ì˜ ì•”ê¸° ë„ìš°ë¯¸ğŸ“–ğŸ“–</title>
  <style>
    .seg-prefix { color:#d00; font-weight:700; } /* ë¹¨ê°• */
    .seg-root   { color:inherit; }               /* ê²€ì •(ê¸°ë³¸) */
    .seg-suffix { color:#06c; font-weight:700; } /* íŒŒë‘ */
    body { font-family: ui-sans-serif, system-ui, -apple-system; max-width: 720px; margin: 40px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin-bottom: 12px; }
    .row { display: flex; gap: 8px; }
    input[type="text"] { flex: 1; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 10px 16px; border: 1px solid #333; background:#111; color:#fff; border-radius:10px; cursor:pointer; }
    button:disabled { opacity: .6; cursor: wait; }
    #ResultArea { margin-top: 18px; white-space: pre-wrap; line-height: 1.6; border: 1px solid #eee; border-radius: 10px; padding: 12px; }
  </style>
</head>
<body>
  <h1>ğŸ“–ğŸ“–ì¤€ìŒ¤ì˜ ì•”ê¸° ë„ìš°ë¯¸ğŸ“–ğŸ“–</h1>
  <div class="row">
    <input id="wordinput" type="text" placeholder="ì•”ê¸°í•˜ê¸° ì–´ë ¤ìš´ ë‹¨ì–´ë¥¼ ì—¬ê¸°ì— ì¨ë³´ì„¸ìš”!" />
    <button id="analbtn">!ë¶„ì„í•˜ê¸°!</button>
  </div>
  <pre id="ResultArea"></pre>

  <script>
  function escapeHtml(s) {
  return String(s ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
  }[m]));
}

/* í•œêµ­ì–´ ì„¤ëª…ì‹("ì ‘ë‘ì–´ re-ëŠ” ...")ì—ì„œë„ ì›í˜•ì„ ì¶”ì¶œí•˜ë ¤ëŠ” ê°€ë²¼ìš´ ê·œì¹™ */
function extractMorphemes(segments) {
  let prefix=null, root=null, suffix=null;

  // ì˜ì–´ ìŠ¤í‚¤ë§ˆê°€ ì˜¨ë‹¤ë©´ ê·¸ëŒ€ë¡œ
  if (segments && typeof segments === "object") {
    if (typeof segments.prefix === "string") prefix = segments.prefix.replace(/-$/,"").trim() || null;
    if (typeof segments.root   === "string") root   = segments.root.replace(/^-|-$/g,"").trim()   || null;
    if (typeof segments.suffix === "string") suffix = segments.suffix.replace(/^-/, "").trim()     || null;
  }

  // í•œêµ­ì–´ ìŠ¤í‚¤ë§ˆ(ì„¤ëª… ë¬¸ì¥)ì—ì„œ ì¶”ì¶œ ì‹œë„
  if (!prefix && typeof segments?.["ì ‘ë‘ì–´"] === "string") {
    const m = segments["ì ‘ë‘ì–´"].match(/([A-Za-z]+)-|([A-Za-z]+)\b/);
    prefix = (m && (m[1] || m[2])) || null;
  }
  if (!root && typeof segments?.["ì–´ê·¼"] === "string") {
    const m = segments["ì–´ê·¼"].match(/\b([A-Za-z]+)\b/);
    root = (m && m[1]) || null;
  }
  if (!suffix && typeof segments?.["ì ‘ë¯¸ì‚¬"] === "string") {
    const m = segments["ì ‘ë¯¸ì‚¬"].match(/-([A-Za-z]+)|\b([A-Za-z]+)\b/);
    suffix = (m && (m[1] || m[2])) || null;
  }

  return { prefix, root, suffix };
}

/* ë‹¨ì–´ë¥¼ ì ‘ë‘/ì–´ê·¼/ì ‘ë¯¸ì‚¬ë¡œ ìƒ‰ì¹  (ê°€ëŠ¥í•œ ë¶€ë¶„ë§Œ) */
function colorizeWord(word, segs) {
  const w = String(word || "");
  const lw = w.toLowerCase();
  const p = segs.prefix ? segs.prefix.toLowerCase() : null;
  const r = segs.root   ? segs.root.toLowerCase()   : null;
  const s = segs.suffix ? segs.suffix.toLowerCase() : null;

  let html = "";
  let pos = 0;

  // 1) ì ‘ë‘ì–´ê°€ "ì •í™•íˆ ì•"ì— ìˆìœ¼ë©´ ë¹¨ê°•
  if (p && lw.startsWith(p)) {
    const pre = w.slice(0, p.length);
    html += `<span class="seg-prefix">${escapeHtml(pre)}</span>`;
    pos = p.length;
  }

  // 2) ì ‘ë¯¸ì‚¬ê°€ "ì •í™•íˆ ë’¤"ì— ìˆìœ¼ë©´ ìœ„ì¹˜ ê¸°ì–µ
  let suffixStart = null;
  if (s && lw.endsWith(s)) {
    suffixStart = w.length - s.length;
  }

  // 3) ì–´ê·¼ì´ ìˆìœ¼ë©´ ê·¸ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ê²€ì •ìœ¼ë¡œ í‘œì‹œ
  if (r) {
    const idx = lw.indexOf(r, pos);
    if (idx !== -1 && (suffixStart === null || idx + r.length <= suffixStart)) {
      // ì ‘ë‘ì–´ ì´í›„~ì ‘ë¯¸ì–´ ì´ì „ ì‚¬ì´ì˜ ì¼ë°˜ ë¶€ë¶„(ìˆë‹¤ë©´) ì¶”ê°€
      if (idx > pos) html += escapeHtml(w.slice(pos, idx));
      // ì–´ê·¼(ê²€ì •)
      html += `<span class="seg-root">${escapeHtml(w.slice(idx, idx + r.length))}</span>`;
      pos = idx + r.length;
    }
  }

  // 4) ì ‘ë¯¸ì‚¬ ì²˜ë¦¬
  if (suffixStart !== null) {
    // ì–´ê·¼ ì´í›„~ì ‘ë¯¸ì‚¬ ì´ì „ ì¼ë°˜ ë¶€ë¶„
    if (pos < suffixStart) html += escapeHtml(w.slice(pos, suffixStart));
    // ì ‘ë¯¸ì‚¬(íŒŒë‘)
    html += `<span class="seg-suffix">${escapeHtml(w.slice(suffixStart))}</span>`;
    pos = w.length;
  }

  // 5) ë‚¨ì€ ë¶€ë¶„(ì•„ë¬´ ê·œì¹™ì—ë„ ì•ˆ ê±¸ë¦° ì¤‘ê°„/ë)ì€ ê¸°ë³¸ ê²€ì •
  if (pos < w.length) html += escapeHtml(w.slice(pos));

  // ì–´ëŠ ê²ƒë„ ë§¤ì¹­ ì•ˆ ë˜ë©´(=htmlì´ ë¹„ì–´ìˆìœ¼ë©´) ì›ë¬¸ ë°˜í™˜
  return html || escapeHtml(w);
}
    
  const $input = document.getElementById("wordinput");
  const $btn = document.getElementById("analbtn");
  const $out = document.getElementById("ResultArea");

  function setBusy(b) {
    $btn.disabled = b;
    $btn.textContent = b ? "ë¶„ì„ ì¤‘..." : "ë¶„ì„í•˜ê¸°";
  }

  function renderResult(j) {
    // ì˜ì–´/í•œêµ­ì–´ ìŠ¤í‚¤ë§ˆ ëª¨ë‘ ì§€ì›
    const word      = j.word ?? j["ë‹¨ì–´"] ?? "";
    const segments  = j.segments ?? j["ë¶„ì„ ê²°ê³¼"] ?? {};
    const meaning   = j.meaning ?? j["ë‹¨ì–´ ëœ»"] ?? {};
    const etymology = j.etymology ?? j["ì–´ì›"] ?? "";
    const mnemonic  = j.mnemonic_image ?? j["ì‰½ê²Œ ì™¸ìš°ë ¤ë©´?"] ?? "";

    const lines = [];
    if (word) lines.push(`â— ë‹¨ì–´: ${word}`);

    // 1) í˜•íƒœì†Œ/ë¶„ì„ ê²°ê³¼
    // ì˜ì–´ ìŠ¤í‚¤ë§ˆ: { prefix, root, suffix, other_morphemes[] }
    if (segments && (segments.prefix || segments.root || segments.suffix || Array.isArray(segments.other_morphemes))) {
      if (segments.prefix)  lines.push(`â— ì ‘ë‘ì–´: ${segments.prefix}`);
      if (segments.root)    lines.push(`â— ì–´ê·¼: ${segments.root}`);
      if (segments.suffix)  lines.push(`â— ì ‘ë¯¸ì‚¬: ${segments.suffix}`);
      if (Array.isArray(segments.other_morphemes) && segments.other_morphemes.length) {
        lines.push(`â— ê¸°íƒ€ êµ¬ì„±: ${segments.other_morphemes.join(", ")}`);
      }
    }
    // í•œêµ­ì–´ ìŠ¤í‚¤ë§ˆ(ì„¤ëª… ë¬¸ì¥): { "ì ‘ë‘ì–´": "...", "ì–´ê·¼": "...", "ì ‘ë¯¸ì‚¬": "..." }
    if (segments && (segments["ì ‘ë‘ì–´"] || segments["ì–´ê·¼"] || segments["ì ‘ë¯¸ì‚¬"])) {
      if (segments["ì ‘ë‘ì–´"]) lines.push(`â— ì ‘ë‘ì–´: ${segments["ì ‘ë‘ì–´"]}`);
      if (segments["ì–´ê·¼"])   lines.push(`â— ì–´ê·¼: ${segments["ì–´ê·¼"]}`);
      if (segments["ì ‘ë¯¸ì‚¬"]) lines.push(`â— ì ‘ë¯¸ì‚¬: ${segments["ì ‘ë¯¸ì‚¬"]}`);
    }

    // 2) ëœ»
    const kr = meaning.kr ?? meaning["í•œêµ­ì–´"];
    const en = meaning.en ?? meaning["ì˜ì˜"];
    if (kr) lines.push(`â— ëœ»(í•œ): ${kr}`);
    if (en) lines.push(`â— ëœ»(ì˜): ${en}`);

    // 3) ì–´ì›
    if (etymology) lines.push(`â— ì–´ì›: ${etymology}`);

    // 4) ì—°ìƒ ì´ë¯¸ì§€
    if (mnemonic) lines.push(`â— ì—°ìƒ ì´ë¯¸ì§€: ${mnemonic}`);

    // ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬(ë°±ì—”ë“œì—ì„œ error/detail ë³´ë‚¼ ë•Œ)
    if (j.error) {
      lines.length = 0;
      lines.push("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      lines.push(`- error: ${j.error}`);
      if (j.detail) lines.push(`- detail: ${typeof j.detail === "string" ? j.detail : JSON.stringify(j.detail)}`);
    }

    // ì•„ë¬´ ê²ƒë„ ëª» ë½‘ì•˜ìœ¼ë©´ ì›ë¬¸ ë…¸ì¶œ(ë””ë²„ê¹…ìš©)
    if (lines.length === 0) {
      $out.textContent = typeof j === "string" ? j : JSON.stringify(j, null, 2);
      return;
    }

    $out.textContent = lines.join("\n");
  }

  async function analyze() {
    const word = ($input.value || "").trim();
    if (!word) return alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
    setBusy(true);
    $out.textContent = "ë¶„ì„ ì¤‘...";

    try {
      const res = await fetch("/analyze", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ word })
      });

      const text = await res.text();
      let data;
      try { data = JSON.parse(text); }
      catch { data = { raw: text }; }

      renderResult(data);
    } catch (e) {
      $out.textContent = "ìš”ì²­ ì‹¤íŒ¨: " + (e?.message || e);
    } finally {
      setBusy(false);
    }
  }

  $btn.addEventListener("click", analyze);
  $input.addEventListener("keydown", (e) => { if (e.key === "Enter") analyze(); });
  </script>
  <footer class="disclaimer" role="note" aria-label="AI disclaimer">
  AIì˜ íŠ¹ì„±ìƒ <strong>í™˜ê°</strong>(ë¶€ì •í™•í•œ ì •ë³´)ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ë‹¨ì–´ ì•”ê¸°ì— <strong>ì°¸ê³ ìš©</strong>ìœ¼ë¡œë§Œ í™œìš©í•´ ì£¼ì„¸ìš”.
</footer>
</body>
</html>




